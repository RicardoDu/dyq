预定设计思路：

1. 添加自定义注解(说明)

   ElementType.TYPE：

   ```java
   - @Service: 扫描service.impl内文件，beanId为注解的value值（对应service的首字母小写）
   - @Component: 扫描utils内文件，beanId为注解的value值（本文件名的首字母小写）
   - @Repository:扫描dao.impl内文件，beanId为注解的value值（对应dao的首字母小写）
   ```

   ElementType.FIELD：

   ```java
   - @Autowired: 只能在ElementType.TYPE型注解标记的类内部生效  （查询方式 声明的实体类的类名的首字母小写 如不存在对应bean则实例化所声明的）
   ```

   PS:暂定只对ElementType.TYPE注解标记的类进行bean的初始化

2. 实现方式：

   ```java
   private static Map<String, Object> map = new HashMap<>();  // 存储对象  一级缓存
   private static Map<String, Object> earlyMap = new HashMap<>();  // 存储对象  二级缓存
   private static Map<String, Object> basicMap = new HashMap<>();  // 存储对象  三级缓存
   private static Set<String> currentBean = new HashSet<>();  //是否为当前正创建
   private static Map<String,Set<String>> sonMap = new HashMap<>();  //autowired对应Bean
   private static List<Map<String,Object>> toDealList = new ArrayList<>(); 
   ```

   1. 首先依次扫描ElementType.TYPE类注解

   2. 对于ElementType.TYPE类注解，扫描各自路径内文件得到list<Class>

   3. 遍历得到的class文件，判断是否存在注解

   4. 存在注解，通过反射创建bean存入到basicMap

   5. 遍历文件 看是否存在autowired注解 不存在则将basicMap->map(是否进一步操作？)

   6. 存在则 将@autowird声明的类转化为beanId 存入sonMap  方便后续处理

   7. ElementType.TYPE类全部扫描完成

   8. 遍历sonMap

      1. map中存在bean？存在则continue;
      2. currentBean存在？
         1. 否
            1. 加入currentBean
            2. 设定flag判断是否发生循环依赖
            3. 遍历Set<String>
               1. 判断map中是否存在该bean
               2. 存在则取出
               3. 不存在 判断currentBean
                  1. 是:earlyMap存在?取出:不存在:basicMap-->earlyMap(是否进一步操作？) 并将返回bean同时flag = true;
                  2. 否：判断sonMap中是否存在该bean 
                     1. 是：重复8直到获得返回bean
                     2. 否：通过反射创建bean
               4. 加入toDealList
               5. flag
                  1. 是：earlyMap获取bean  通过toDealList装配 -> map
                  2. 否：basicMap获取bean  通过toDealList装配 -> map(是否进一步操作？) 
            4. 从currentBean中删除  返回bean
         2. 是、earlyMap存在?取出:不存在:basicMap-->earlyMap(是否进一步操作？) 并将返回bean

      

      

      

   

   